Кроме обычных чисел, существуют так называемые «специальные числовые значения», которые относятся к этому типу данных: Infinity, -Infinity и NaN.


Тип BigInt был добавлен в JavaScript, чтобы дать возможность работать с целыми числами произвольной длины.
Чтобы создать значение типа BigInt, необходимо добавить n в конец числового литерала.


let phrase = `Обратные кавычки позволяют встраивать переменные ${str}`;
let name = "Иван";

// Вставим переменную
alert( `Привет, ${name}!` ); // Привет, Иван!

// Вставим выражение
alert( `результат: ${1 + 2}` ); // результат: 3


Значение «null» - это специальное значение, которое представляет собой «ничего», «пусто» или «значение неизвестно.


Оператор typeof возвращает тип аргумента. Это полезно, когда мы хотим обрабатывать значения различных типов по-разному или просто хотим сделать проверку.


В JavaScript есть 8 основных типов данных.

Семь из них называют «примитивными» типами данных:
number для любых чисел: целочисленных или чисел с плавающей точкой; целочисленные значения ограничены диапазоном ±(253-1).
bigint для целых чисел произвольной длины.
string для строк. Строка может содержать ноль или больше символов, нет отдельного символьного типа.
boolean для true/false.
null для неизвестных значений – отдельный тип, имеющий одно значение null.
undefined для неприсвоенных значений – отдельный тип, имеющий одно значение undefined.
symbol для уникальных идентификаторов.
И один не является «примитивным» и стоит особняком:
object для более сложных структур данных.
Оператор typeof позволяет нам увидеть, какой тип данных сохранён в переменной.

Имеет две формы: typeof x или typeof(x).
Возвращает строку с именем типа. Например, "string".
Для null возвращается "object" – это ошибка в языке, на самом деле это не объект.

---------------------------------------------------------------------------------------------------------------------

-----------prompt-------------------
Функция prompt принимает два аргумента:
result = prompt(title, [default]);
Например:
let age = prompt('Сколько тебе лет?', 100);
alert(`Тебе ${age} лет!`); // Тебе 100 лет!
------------confirm-------------------
Синтаксис:
result = confirm(question);
Функция confirm отображает модальное окно с текстом вопроса question и двумя кнопками: OK и Отмена.
Результат – true, если нажата кнопка OK. В других случаях – false.
Например:
let isBoss = confirm("Ты здесь главный?");
alert( isBoss ); // true, если нажата OK

-----------------Строковое преобразование-------------------------
Пример:
let value = true;
alert(typeof value); // boolean
value = String(value); // теперь value это строка "true"
alert(typeof value); // string
-------------------Численное преобразование-----------------------
Пример:
let str = "123";
alert(typeof str); // string
let num = Number(str); // становится числом 123
alert(typeof num); // number
---------------------Логическое преобразование----------------------
Например:
alert( Boolean(1) ); // true
alert( Boolean(0) ); // false
alert( Boolean("Привет!") ); // true
alert( Boolean("") ); // false
-------------------Возведение в степень **----------------------------
В выражении a ** b оператор возведения в степень умножает a на само себя b раз.
------------------Приведение к числу, унарный +-----------------------
// Преобразует не числа в числа
alert( +true ); // 1
alert( +"" );   // 0
На самом деле это то же самое, что и Number(...), только короче.
-------
Оператор строгого равенства === проверяет равенство без приведения типов.
-------
------------------Условный оператор „?“-------------------------------
Синтаксис:
let result = условие ? значение1 : значение2;
Сначала вычисляется условие: если оно истинно, тогда возвращается значение1, в противном случае – значение2.
Например:
let age = prompt('Возраст?', 18);
let message = (age < 3) ? 'Здравствуй, малыш!' :
  (age < 18) ? 'Привет!' :
  (age < 100) ? 'Здравствуйте!' :
  'Какой необычный возраст!';
alert( message );
Вот как это выглядит при использовании if..else:
if (age < 3) {
  message = 'Здравствуй, малыш!';
} else if (age < 18) {
  message = 'Привет!';
} else if (age < 100) {
  message = 'Здравствуйте!';
} else {
  message = 'Какой необычный возраст!';
}
Иногда оператор «вопросительный знак» ? используется в качестве замены if:
let company = prompt('Какая компания создала JavaScript?', '');
(company == 'Netscape') ?
   alert('Верно!') : alert('Неправильно.');
В зависимости от условия company == 'Netscape', будет выполнена либо первая, либо вторая часть после ?.
Здесь мы не присваиваем результат переменной. Вместо этого мы выполняем различный код в зависимости от условия.
Не рекомендуется использовать оператор вопросительного знака таким образом.
---------------------ИЛИ «||» находит первое истинное значение-----------------------------
alert( 1 || 0 ); // 1
alert( true || 'no matter what' ); // true
alert( null || 1 ); // 1 (первое истинное значение)
alert( null || 0 || 1 ); // 1 (первое истинное значение)
alert( undefined || null || 0 ); // 0 (поскольку все ложно, возвращается последнее значение)
-Получение первого истинного значения из списка переменных или выражений.
let currentUser = null;
let defaultUser = "John";
let name = currentUser || defaultUser || "unnamed";
alert( name ); // выбирается "John" – первое истинное значение
-Сокращённое вычисление.
В приведённом ниже примере x не изменяется:
let x;
true || (x = 1);
alert(x); // undefined, потому что (x = 1) не вычисляется
Если бы первый аргумент имел значение false, то || приступил бы к вычислению второго и выполнил операцию присваивания:
let x;
false || (x = 1);
alert(x); // 1
------------------------И «&&» находит первое ложное значение-------------------------------
Примеры:
// Если первый операнд истинный,
// И возвращает второй:
alert( 1 && 0 ); // 0
alert( 1 && 5 ); // 5
// Если первый операнд ложный,
// И возвращает его. Второй операнд игнорируется
alert( null && 5 ); // null
alert( 0 && "no matter what" ); // 0
Можно передать несколько значений подряд. В таком случае возвратится первое «ложное» значение, на котором остановились вычисления.
alert( 1 && 2 && null && 3 ); // null
Когда все значения верны, возвращается последнее
alert( 1 && 2 && 3 ); // 3
Как и оператор ИЛИ ||, И && иногда может заменять if.
К примеру:
let x = 1;
(x > 0) && alert( 'Greater than zero!' );
Получился аналог:
let x = 1;
if (x > 0) {
  alert( 'Greater than zero!' );
}
-----------------------Оператор нулевого слияния (??)-------------------------
Результат выражения a ?? b будет следующим:
если a определено, то a,
если a не определено, то b.
Иначе говоря, оператор ?? возвращает первый аргумент, если он не null/undefined, иначе второй.
Вот как можно переписать выражение result = a ?? b, используя уже знакомые нам операторы:
result = (a !== null && a !== undefined) ? a : b;
Например, здесь мы отобразим user, если её значение не null/undefined, в противном случае Аноним:
let user;
alert(user ?? "Аноним"); // Аноним (user не существует)
А вот пример, когда user присвоено значение:
let user = "Иван";
alert(user ?? "Аноним"); // Иван (user существует)
Кроме этого, можно записать последовательность из операторов ??, чтобы получить первое значение из списка, которое не является null/undefined.
Для этого воспользуемся оператором ??:
let firstName = null;
let lastName = null;
let nickName = "Суперкодер";
// показывает первое значение, которое определено:
alert(firstName ?? lastName ?? nickName ?? "Аноним"); // Суперкодер
Оператор ИЛИ || можно использовать для того же, что и ??, как это было показано в предыдущей главе.
Например, если в приведённом выше коде заменить ?? на ||, то будет тот же самый результат:
let firstName = null;
let lastName = null;
let nickName = "Суперкодер";
// показывает первое истинное значение:
alert(firstName || lastName || nickName || "Аноним"); // Суперкодер
Важное различие между ними заключается в том, что:
|| возвращает первое истинное значение.
?? возвращает первое определённое значение.
Рассмотрим следующий пример:
let height = 0;
alert(height || 100); // 100
alert(height ?? 100); // 0
Оператор нулевого слияния ?? — это быстрый способ выбрать первое «определённое» значение из списка.
Используется для присвоения переменным значений по умолчанию:
// будет height=100, если переменная height равна null или undefined
height = height ?? 100;
----------Цикл «while»-----------
Цикл while имеет следующий синтаксис:

while (condition) {
  // код
  // также называемый "телом цикла"
}
Код из тела цикла выполняется, пока условие condition истинно.
Любое выражение или переменная может быть условием цикла, а не только сравнение: условие while вычисляется и преобразуется в логическое значение.

Например, while (i) – более краткий вариант while (i != 0):

let i = 3;
while (i) { // когда i будет равно 0, условие станет ложным, и цикл остановится
  alert( i );
  i--;
}

-------------Цикл «do…while»-----------------------
Проверку условия можно разместить под телом цикла, используя специальный синтаксис do..while:

do {
  // тело цикла
} while (condition);
Цикл сначала выполнит тело, а затем проверит условие condition, и пока его значение равно true, он будет выполняться снова и снова.

Например:

let i = 0;
do {
  alert( i );
  i++;
} while (i < 3);

----------------------Цикл «for»-------------------------
Более сложный, но при этом самый распространённый цикл — цикл for.

Выглядит он так:

for (начало; условие; шаг) {
  // ... тело цикла ...
}
Давайте разберёмся, что означает каждая часть, на примере. Цикл ниже выполняет alert(i) для i от 0 до (но не включая) 3:

for (let i = 0; i < 3; i++) { // выведет 0, затем 1, затем 2
  alert(i);
}
Рассмотрим конструкцию for подробней:
	
начало	let i = 0	Выполняется один раз при входе в цикл
условие	i < 3	Проверяется перед каждой итерацией цикла. Если оно вычислится в false, цикл остановится.
тело	alert(i)	Выполняется снова и снова, пока условие вычисляется в true.
шаг	i++	Выполняется после тела цикла на каждой итерации перед проверкой условия

Любая часть for может быть пропущена.
Для примера, мы можем пропустить начало если нам ничего не нужно делать перед стартом цикла.
Вот так:

let i = 0; // мы уже имеем объявленную i с присвоенным значением

for (; i < 3; i++) { // нет необходимости в "начале"
  alert( i ); // 0, 1, 2
}
Можно убрать и шаг:

let i = 0;

for (; i < 3;) {
  alert( i++ );
}
Это сделает цикл аналогичным while (i < 3).
А можно и вообще убрать всё, получив бесконечный цикл:

for (;;) {
  // будет выполняться вечно
}

-------------------Прерывание цикла: «break»----------------------
Обычно цикл завершается при вычислении условия в false.

Но мы можем выйти из цикла в любой момент с помощью специальной директивы break.

Например, следующий код подсчитывает сумму вводимых чисел до тех пор, пока посетитель их вводит, а затем – выдаёт:

let sum = 0;

while (true) {

  let value = +prompt("Введите число", '');

  if (!value) break; // (*)

  sum += value;

}
alert( 'Сумма: ' + sum );

------------------------Переход к следующей итерации: continue----------------------------------
Директива continue – «облегчённая версия» break. При её выполнении цикл не прерывается, а переходит к следующей итерации (если условие все ещё равно true).

Её используют, если понятно, что на текущем повторе цикла делать больше нечего.

Например, цикл ниже использует continue, чтобы выводить только нечётные значения:

for (let i = 0; i < 10; i++) {

  // если true, пропустить оставшуюся часть тела цикла
  if (i % 2 == 0) continue;

  alert(i); // 1, затем 3, 5, 7, 9
}

---------------------Конструкция "switch"--------------------------
Синтаксис
Конструкция switch имеет один или более блок case и необязательный блок default.

Выглядит она так:

switch(x) {
  case 'value1':  // if (x === 'value1')
    ...
    [break]

  case 'value2':  // if (x === 'value2')
    ...
    [break]

  default:
    ...
    [break]
}

------------Объявление функции------------------
Пример объявления функции:

function showMessage() {
  alert( 'Всем привет!' );
}

---------------Выбор имени функции-------------------
Например, функции, начинающиеся с "show" обычно что-то показывают.

Функции, начинающиеся с…

"get…" – возвращают значение,
"calc…" – что-то вычисляют,
"create…" – что-то создают,
"check…" – что-то проверяют и возвращают логическое значение, и т.д.
Примеры таких имён:

showMessage(..)     // показывает сообщение
getAge(..)          // возвращает возраст (в каком-либо значении)
calcSum(..)         // вычисляет сумму и возвращает результат
createForm(..)      // создаёт форму (и обычно возвращает её)
checkPermission(..) // проверяет доступ, возвращая true/false

!!--------------------------Function Expression-------------------------
Функция в JavaScript – это не магическая языковая структура, а особого типа значение.

Синтаксис, который мы использовали до этого, называется Function Declaration (Объявление Функции):

function sayHi() {
  alert( "Привет" );
}
Существует ещё один синтаксис создания функций, который называется Function Expression (Функциональное Выражение).

Оно выглядит вот так:

let sayHi = function() {
  alert( "Привет" );
};
--------------------------------Функции-«колбэки»----------------------------------
Рассмотрим ещё примеры функциональных выражений и передачи функции как значения.

Давайте напишем функцию ask(question, yes, no) с тремя параметрами:

question
Текст вопроса
yes
Функция, которая будет вызываться, если ответ будет «Yes»
no
Функция, которая будет вызываться, если ответ будет «No»
Наша функция должна задать вопрос question и, в зависимости от того, как ответит пользователь, вызвать yes() или no():

function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

function showOk() {
  alert( "Вы согласны." );
}

function showCancel() {
  alert( "Вы отменили выполнение." );
}

// использование: функции showOk, showCancel передаются в качестве аргументов ask
ask("Вы согласны?", showOk, showCancel);
=======
Мы можем переписать этот пример значительно короче, используя Function Expression:

function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

ask(
  "Вы согласны?",
  function() { alert("Вы согласились."); },
  function() { alert("Вы отменили выполнение."); }
);
==========================
Еще примеры:
Такой код не сработает.
let age = 16; // присвоим для примера 16

if (age < 18) {
  welcome();               // \   (выполнится)
                           //  |
  function welcome() {     //  |
    alert("Привет!");      //  |  Function Declaration доступно
  }                        //  |  во всём блоке кода, в котором объявлено
                           //  |
  welcome();               // /   (выполнится)

} else {

  function welcome() {
    alert("Здравствуйте!");
  }
}

// здесь фигурная скобка закрывается,
// поэтому Function Declaration, созданные внутри блока кода выше -- недоступны отсюда.

welcome(); // Ошибка: welcome is not defined
---------------------
Верным подходом будет воспользоваться функцией, объявленной при помощи Function Expression, и присвоить значение welcome переменной, объявленной снаружи if, что обеспечит нам нужную видимость.

Такой код работает, как ожидалось:

let age = prompt("Сколько Вам лет?", 18);

let welcome;

if (age < 18) {

  welcome = function() {
    alert("Привет!");
  };

} else {

  welcome = function() {
    alert("Здравствуйте!");
  };

}

welcome(); // теперь всё в порядке
--------------------------
Можно упростить этот код ещё сильнее, используя условный оператор ?:

let age = prompt("Сколько Вам лет?", 18);

let welcome = (age < 18) ?
  function() { alert("Привет!"); } :
  function() { alert("Здравствуйте!"); };

welcome(); // теперь всё в порядке
============================================================================================
============================================================================================
=================================Стрелочные функции, основы==================================
Он называется «функции-стрелки» или «стрелочные функции» (arrow functions), т.к. выглядит следующим образом:

let func = (arg1, arg2, ...argN) => expression;

Другими словами, это сокращённая версия:

let func = function(arg1, arg2, ...argN) {
  return expression;
};

Давайте рассмотрим конкретный пример:

let sum = (a, b) => a + b;

/* Эта стрелочная функция представляет собой более короткую форму:

let sum = function(a, b) {
  return a + b;
};
*/

alert( sum(1, 2) ); // 3

Стрелочные функции можно использовать так же, как и Function Expression.

Например, для динамического создания функции:

let age = prompt("Сколько Вам лет?", 18);

let welcome = (age < 18) ?
  () => alert('Привет!') :
  () => alert("Здравствуйте!");

welcome();

========================Многострочные стрелочные функции==============================
Пример:
let sum = (a, b) => {  // фигурная скобка, открывающая тело многострочной функции
  let result = a + b;
  return result; // если мы используем фигурные скобки, то нам нужно явно указать "return"
};

alert( sum(1, 2) ); // 3

--------------Стрелочные функции:-----------------повтор

// выражение в правой части
let sum = (a, b) => a + b;

// многострочный код в фигурных скобках { ... }, здесь нужен return:
let sum = (a, b) => {
  // ...
  return a + b;
}

// без аргументов
let sayHi = () => alert("Привет");

// с одним аргументом
let double = n => n * 2;























































